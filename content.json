{"meta":{"title":1988,"subtitle":null,"description":"Step by step","author":1988,"url":"https://ly1988.github.io"},"pages":[],"posts":[{"title":"","slug":"文件上传限制绕过技巧","date":"2018-08-16T09:59:01.829Z","updated":"2018-08-16T13:15:39.346Z","comments":true,"path":"2018/08/16/文件上传限制绕过技巧/","link":"","permalink":"https://ly1988.github.io/2018/08/16/文件上传限制绕过技巧/","excerpt":"","text":"title: 文件上传限制绕过技巧date: 2018-08-16 17:59:01 tags:========== 文件上传限制绕过技巧 ==========##简介文件上传漏洞是web安全中经常利用到的一种漏洞形式。一些web应用程序中允许上传图片，文本或者其他资源到指定的位置，文件上传漏洞就是利用这些可以上传的地方将恶意代码植入到服务器中，再通过url去访问以执行代码。但在一些安全性较高的web应用中，往往会有各种上传限制和过滤，导致我们无法上传特定的文件。本文将就此展开讨论，通过本文的学习你将了解到Web应用中文件上传的处理和验证发送流程，以及我们该如何绕过这些验证。 ##客户端验证 客户端验证是一种发生在输入被实际发送至服务器之前进行的验证。这类验证大都都是通过JavaScript，VBScript或HTML5来完成的。虽然，这对于用户来说响应速度更快体验也更好。但对于恶意攻击者来说，这些验证似乎就显得略为低级。 ##客户端验证绕过 这种类型的绕过也非常简单，我们可以关闭浏览器上的JavaScript或是在浏览器发出请求之后，在被发送至服务器之前来篡改该HTTP请求即可。 正如你所看到的，此JavaScript仅在请求被实际发送至服务器之前处理你的请求，以及检查你上传的文件扩展名是否为（jpg，jpeg，bmp，gif，png）。这样的话，我们就可以拦截该请求并篡改文件内容（恶意代码），然后将图片扩展名更改为可执行文件的扩展名（如php，asp）。 如上图所示，我们试图上传一个直接的PHP文件，JavaScript阻止了我们的文件上传请求。 我们可以通过浏览器来上传一个正常的图片格式来绕过该验证，然后拦截该请求再将其改回为php格式并将文件内容替换为我们的恶意代码，这样我们就能够成功上传我们的恶意php脚本了。 ##文件名验证 顾名思义，就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传。检查扩展名是否合法有两种常用策略，即黑名单和白名单策略。 黑名单策略，即文件扩展名在黑名单中的为不合法。白名单策略，即文件扩展名不在白名单中的均为不合法。相对于黑名单，白名单策略更加安全的。通过限制上传类型为只有我们接受的类型，可以较好的保证安全，因为黑名单我们可以使用各种方法来进行注入和突破。 ##文件名绕过 我们可以通过上传一些平时不怎么用的容易被人忽视的文件扩展名，来绕过这种类型的验证。绕过黑白名单策略： 黑名单绕过 通过上传不受欢迎的php扩展来绕过黑名单。例如：pht，phpt，phtml，php3，php4，php5，php6 白名单绕过 通过某种类型的技巧来绕过白名单，例如添加空字节注入（shell.php％00.gif），或使用双重扩展来上传文件（shell.jpg.php）。 此外，我们还可以尝试扩展名大小写来绕过，例如：pHp，Php，phP。 ##Content-Type验证 Content-Type（内容类型），一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件。例如，一些图像文件上传通过检查文件的内容类型是否为图像类型来验证上传的图像。 ##Content-Type绕过 该类型的绕过也非常简单，只需将“Content-Type”的参数类型更改为“image/ *”即可，例如“image/png”, “image/jpeg”, “image/gif”。 1. &lt;?php2.3. $mimetype = mime_content_type($_FILES[‘file’][‘tmp_name’]);4. if(in_array($mimetype, array(‘image/jpeg’, ‘image/gif’, ‘image/png’))) {5. move_uploaded_file($_FILES[‘file’][‘tmp_name’], ‘/uploads/‘ . $_FILES[‘file’][‘name’]);6. echo ‘OK’;7.8. } else {9. echo ‘Upload a real image’;10. } 以上代码会检查Content-Type header中的MIME类型，仅接受类型为image/jpeg, image/gif, image/png的文件上传。我们只需只需将“Content-Type”的参数类型更改为其可接受的类型即可绕过。 ##CONTENT-LENGTH验证 Content-Length验证是指服务器会对上传的文件内容长度进行检查，超出限制大小的文件将不允许被上传。虽然这种类型的验证不是很受欢迎，但在一些应用的文件上传中也时常能碰到。 ##CONTENT-LENGTH绕过 1. if ($_FILES[“fileToUpload”][“size”] &gt; 30) {2. echo “Sorry, your file is too large.”;3. } 针对这种类型的验证，我们可以通过上传一些非常短的恶意代码来绕过。上传文件的大小取决于，Web服务器上的最大长度限制。我们可以使用不同大小的文件来fuzzing上传程序，从而计算出它的限制范围。","categories":[],"tags":[]},{"title":"","slug":"hexo-github遇到的问题","date":"2018-08-16T09:13:15.843Z","updated":"2018-08-16T09:42:33.489Z","comments":true,"path":"2018/08/16/hexo-github遇到的问题/","link":"","permalink":"https://ly1988.github.io/2018/08/16/hexo-github遇到的问题/","excerpt":"","text":"title:hexo-github遇到的问题date: 2018-08-16 12:05:13 tags:我来解释一下前段时间一直没有更博的原因！这个hexo deploy出问题。。 fatal: could not read Username for ‘https://github.com‘: No errorFATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: HttpRequestException encountered. ʱbash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for ‘https://github.com‘: No error at ChildProcess.&lt;anonymous&gt; (C:\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (C:\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29) at maybeClose (internal/child_process.js:920:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:230:5) 就这几行代码。 本来先是尝试了删除.deploy_git 这个文件的方法，但是没有解决问题。 然后又是什么邮箱账号密码登录出错的原因，试了这些，依然没有作用。就先搁置了这个问题，想着先慢慢写博文，之后解决了再发布。 于是拖到了八月份的这天。 我又开始尝试，结果居然问题出在了我从来没想到地方，是在_config.yml这个配置文件的最后两行，deploy: type: git repository: git@github.com:ly1988/ly1988.github.io.git branch: master 开始的repo是这样的：https://github.com/username/…之前一直没有问题。不过现在解决了。","categories":[],"tags":[]},{"title":"","slug":"利用暑假高效学习！","date":"2018-08-11T12:06:11.317Z","updated":"2018-08-11T12:14:51.910Z","comments":true,"path":"2018/08/11/利用暑假高效学习！/","link":"","permalink":"https://ly1988.github.io/2018/08/11/利用暑假高效学习！/","excerpt":"","text":"title: 利用暑假高效学习！date: 2018-08-11 20:06:11 tags:##暑假来了~ 对于我来说，要是没有规划好自己的整个学习计划，那我的整个暑假就在睡和吃当中度过了，所以我专门从网上找来“如何高效学习“的励志鸡汤，提醒自己！ 我们之所以要高效学习，是“被逼”的。比如很多人喜欢在deadline前几天开始拼命，又比如很多学生在考试前一周开始刷夜，都属于这种情况。 ##干货但是如果没解决好动机问题，在压力之下拼命会让你很容易感到疲惫。可能1个星期，2个星期还可以，再长久不行了。这种情况，最后的结果往往是短时间爆发后更加猛烈地放纵自己。 我们要的不是1天，1个星期的长时间学习，而是希望能让自己具有大阶段范围内“长时间高效学习”的能力，这种能力，如果你找不到内心真正认可，真正能打动你的动机是很难的。 个人认为，好的学习动机应该是：具体化、长短结合、并且和自身需求相结合的。 具体化： 不要再用无法衡量的目标作为自己的动机，而是让它具体化。和“做更优秀的自己”相比，“我要跳槽到Google去工作”就是具体化的动机和目标。 动机具体化了，我们才能找到评判的标准，给自己建立反馈机制（这点在后面会详细说），同时我们也更容易把动机分解，具体点说就是根据大小进行分解，根据周期长短进行分解。 比如“我要跳槽到Google去工作”，大体可以分解成下面的样子： a、了解Goolge的岗位需求，以及自己想要应聘岗位的详细要求 b、学习xxx语言和xxx技术，使自己打到Google的招聘要求 c、认识xxx朋友，给自己争取内推机会 d、…… 如果再详细一些，上面每个子项还可以继续拆分。 具体化之后最大的好处是：你非常明白自己学习是为了什么，你应该做什么事情，以及这些事情你进展到什么阶段了。“长时间高效学习”是个没有终点的“无限”过程，具体化动机相当于给这个过程设定方向，埋下路标，让我们不会迷路，能够坚持走下去。 长短结合： 上面说到了动机（或者说目标）的拆分，我们应该将整体目标拆分成不同的大小目标，根据完成目标的时间周期以及难度，设定长期目标、中期目标、短期目标。 就我个人而言，有段时间每天除工作外保持最少5个小时的高效学习，当时我给自己设定的一个整体目标是：我一定要在2015年出版一本自己的书。 因为出版社已经确定了我的选题（也就是说只要书的内容在规定的时间内写好，书是肯定可以出版的），我便根据这个整体目标给自己确定了不同的周期目标。 6个月周期：完成新书第一稿的写作 第1个月：准备期 第一周：基础资料搜集整理 第二周：确定新书整体框架结构 第三周：与出版社/业内专家沟通，整理反馈意见 第四周：确定新书整体框架结构 第2个月：完成章节1-2初稿的写作 第1周：完成章节1初稿写作 第2-4周：完成章节2初稿写作 …… 实际的目标设定表会比这个更详细一些，限于篇幅不再展开。 做完目标长短结合的分解之后，每个星期，每一天我都很清楚自己要学习哪些东西，并且完成之后会有很确定的反馈。进入到这个节奏之后，坚持5小时并没有想象的那么难。 不知道大家有没有这样的感觉：我们去一个陌生的地方，回来的时候总觉得比去的时候快一点。其实路程是一样的，时间也差不多，唯一的区别就是回来的时候我们知道“目的地”在哪里。未知让人恐惧和放弃，但一旦我们知道自己要做到哪一步，就会轻松很多。 和自身需求结合： 和自身需求结合，是说动机最好和你最想要的、最需要的东西结合起来。 很多人将自己难以坚持归因为“自控力不够，意志力不够”。这个结论既对，又不对。每个人的意志力千差万别，意志力足够强的人确实更容易进入到“长时间高效学习“的状态，但其实大部分人意志力都是一般的，可同样很多人也能做到同样的事情。 如果认为意志力是解决问题的唯一办法，那就会变成另外一个问题了。并且提高意志力，应该是更复杂的一个问题，需要更漫长的时间。 就事论事，我们要解决的是：平凡人如何做到？一个推荐的方法就是和自身需求相结合。 “学习一门新的编程语言”是一个动机，但这个动机不够。“学习一门新的编程语言，然后去xx公司工作”就和需求结合了。 “每个月阅读一本书”是一个动机，同样是不够的。“每个月阅读一本书，然后发书评到豆瓣和朋友圈去接受敬仰的目光”就和需求结合了。 要想清楚，你想要什么呢？什么是最吸引你的？ 面子、金钱、地位、朋友关系、夫妻关系，这些都是很好的结合点。 可能有朋友会说这样是不是太功利了？学习不是为自己变得更好吗？ 让自己更好是总的目标，或者说是结果。而且，让自己更好是个没有止境的过程，大部分时候看起来太过遥远。对普通人来说，让自己坚持下去更需要的是近在眼前的东西。 两者并不矛盾。可能你就是为了钱去学习的，但学习之后并不妨碍你同时也变得更好。 有时候我们的动机太高大上了，反而缺乏一些接地气的东西。 身体： 很多时候，阻碍我们坚持下去的不是我们的意志力，而是我们的身体。 一学习就犯困，看书2个小时就头痛，天天下班后就没有精神不想学习，很有可能是你的身体已经非常疲惫了，大脑给你发出了“休息”的指令。 这时候硬逼着自己去学习，效果肯定不会好，而且对身体的伤害也非常大。 身体素质差，影响的不只是你的精力，还会影响你的心情。压抑、郁闷、抑郁、沮丧，很多负面的情绪让我们根本无法进入学习的状态，而这些负面状态很多时候都是由于缺乏锻炼导致的。 我是在工作最为繁忙，休息时间最少的那个阶段开始启动晨练计划的。每天再困也好，7点左右准时起床，然后到家里附近的体育场去跑步。不多，跑3-5公里，出一身酣畅淋漓的大汗，然后散步回家。洗澡，吃早餐，上班。","categories":[],"tags":[]},{"title":"","slug":"学习Python时总结的小技巧","date":"2018-08-11T11:30:31.525Z","updated":"2018-08-16T09:07:51.657Z","comments":true,"path":"2018/08/11/学习Python时总结的小技巧/","link":"","permalink":"https://ly1988.github.io/2018/08/11/学习Python时总结的小技巧/","excerpt":"","text":"title: 学习Python时总结的小技巧date: 2018-08-11 19:30:31 tags: ##1. 列表推导式 你有一个list：bag = [1, 2, 3, 4, 5] 现在你想让所有元素翻倍，让它看起来是这个样子：[2, 4, 6, 8, 10] 大多初学者，根据之前语言的经验会大概这样来做 bag = [1, 2, 3, 4, 5] for i in range(len(bag)): bag[i] = bag[i] * 2 但是有更好的方法： bag = [elem * 2 for elem in bag] 这叫做Pythpn的列表推导式。 ##2. 遍历列表 继续，还是上面的列表。 如果可能尽量避免这样做： bag = [1, 2, 3, 4, 5] for i in range(len(bag)): print(bag[i]) 取而代之的应该是这样： bag = [1, 2, 3, 4, 5] for i in bag: print(i) 如果x是一个列表，你可以对它的元素进行迭代。多数情况下你不需要各元素的索引，但如果你非要这样做，那就用enumerate函数。它像下边的样子： bag = [1, 2, 3, 4, 5] for index, element in enumerate(bag): print(index, element) ##3. 元素互换 之前我们可能会这样做： a = 5 b = 10 # 交换 a 和 b tmp = a a = b b = tmp Python提供了一个更好的方法： a = 5 b = 10 # 交换a 和 b a, b = b, a ##4. 初始化列表 假如你要一个是10个整数0的列表，你可能首先想到： bag = [] for _ in range(10): bag.append(0) 换个方式： bag = [0] * 10 ##5. 构造字符串 我们经常需要打印字符串。要是有很多变量，避免下面这样： name = &apos;Raymond&apos; age = 22 born_in = &apos;Oakland, CA&apos; string = &apos;Hello my name is &apos; + name + &apos;and I&apos;m &apos; + str(age) + &apos; years old. I was born in &apos; + born_in + &apos;.&apos; print(string) 可以用个漂亮简洁的方法来代替，.format。 这样做： name = &apos;Raymond&apos; age = 22 born_in = &apos;Oakland, CA&apos; string = &apos;Hello my name is {0} and I&apos;m {1} years old. I was born in {2}.&apos;.format(name, age, born_in) print(string)","categories":[],"tags":[]},{"title":"Sqlmap-payload修改姿势（二）","slug":"Sqlmap-payload修改姿势（二）","date":"2018-02-04T04:05:13.000Z","updated":"2018-02-04T04:32:44.562Z","comments":true,"path":"2018/02/04/Sqlmap-payload修改姿势（二）/","link":"","permalink":"https://ly1988.github.io/2018/02/04/Sqlmap-payload修改姿势（二）/","excerpt":"","text":"前两天学习到基本的payload修改姿势，这次继续深挖== xml文件的具体标签 来看 boundaries.xml文件，模板里面分别定义了,,,,,六个标签。 标签： 标签就是我们使用sqlmap注入时候–level的命令，这个标签分别定义了1-5个等级的发包数量，默认是1，表示做最少的检测，level越高，检测的数量越高。level等于2时会检测cookie字段是否有注入，等于3时会检测User-Agent、Host、Referer等HTTP的头部字段是否有注入。 标签：该标签说明了sqlmap使用的条件从句，其中always表示测试所有。 标签:该标签定义了payload写入的位置详见的解释。 标签:举个例来说：假设如下查询语句?id=1’ union SELECT * FROM Persons WHERE City=’Beijing’–+其中?id=1后面的单引号是由前缀标签定义的，–+是由后缀标签定义的，而中间语句所要使用的字符则是由标签定义的，简单来说就是参数的类型。 标签:注入语句的前缀定义了注入中常用到闭合或者注释的字符，例如 右括号)，单引号加右括号’)，两个右括号))等等。 标签:定义了SQL注入的语句的后缀，比如说常见的注释符、也可能是另外的sql语句看具体情况。 完整的payload这里还是不能插入图片，我只能在后面描述了== 标题 说明了每个payload的注入类型，分别就是我们上述所说的6种sqlmap常用的注入类型。 为每个payload的发包数量的等级，与boundary中的level的定义一致。 为每个payload的风险等级，等级越高对数据库的造成的破坏越大。 为每个payload使用的sql查询从句与boundary中的clause定义一致。 为每个payload 要插入的位置。 sql注入模板。 sql注入的请求测试。 SQL注入的request请求中payload。 一般在payload之后前缀之前。 在union查询时字符串使用的列数。 union查询时用来判断列数。 通过SQL注入的response返回包，一般用来判断注入是否成功。 通常用在boolean_blind.xml文件中的布尔盲注用来做比较，判断页面状态。 通常用于报错注入的时候判断。时间盲注和堆叠查询使用。 可以注入成功的union语句。 sqlmap输出payload的详情,有三个子节点分别是、、。 子节点表示数据库类型。 子节点表示数据库版本。 子节点表示操作系统的类型。 sqlmap的注入除了payload还需要其他xml文件想要了解每个标签的作用效果，我们可以通过sqlmap丰富的指令指定使用的xml文件，如果没有指令可以指定xml我们可以手动通过增加、修改、删除xml文件下的元素，来缩小范围，这样我们就能知道每个标签的作用效果。","categories":[],"tags":[]},{"title":"Sqlmap payload修改姿势（一）","slug":"Sqlmap-payload修改姿势","date":"2018-02-02T11:40:04.000Z","updated":"2018-02-02T12:45:03.452Z","comments":true,"path":"2018/02/02/Sqlmap-payload修改姿势/","link":"","permalink":"https://ly1988.github.io/2018/02/02/Sqlmap-payload修改姿势/","excerpt":"","text":"首先来讲讲sqlmap6种探测注入类型： 1, UNION query SQL injection（可联合查询注入） 联合查询简单来说就是通过union关键字将多条查询语句拼接在一起，并且把查询结果作为一个结果以一个表格的形式输出到页面，需要注意的是查询语句要符合1.相同列数2.相似的数据类型3.相同的编码。示例语句：-1’ union select 1,(select user()),(select version())–+，如果 查询结果无法返回到页面，则就需要考虑盲注。 2, Error-based SQL injection（报错型注入） 报错注入的核心思想是通过数据库的“人性化的报错定位机制”将我们要查询的数据通过报错的方式直接回显到页面上来，示例语句：’ and (extractvalue(1,concat(0x7e,(select user()),0x7e)))–+，当然如果报错的数据不能回显到页面上来，就无法使用报错注入，这时候我们就可以考虑是否存在盲注。 3, Boolean-based blind SQL injection（布尔型注入） 布尔盲注的核心思想就是通过判断两种不同的页面状态来进一步推断注入语句是否被执行以及数据是否存在。示例语句：1’ and database() regexp ‘^1’ –+，当我们输入的注入语句无法通过回显以及报错的方式来获取数据，这时候就可能存在盲注，通过判断有跟没有、对或错来判断regexp 是否匹配到数据了。 4, Time-based blind SQL injection（基于时间延迟注入） 如果在测试的时候发现都不存在前面三种所说的注入，那就有可能是时间盲注，时间盲注的特点是无回显，无报错，也没有多种页面状态。这时候就需要通过增加sleep()函数来判断注入语句的执行，而布尔则是根据页面的对错来判断。示例语句：1’ and sleep(5)–+ 如果sleep则说明存在时间盲注 5, Stacked queries SQL injection（可多语句查询注入） 多语句查询注入也叫做堆叠查询，与联合查询有点相似，都可以多条语句查询，堆叠查询的关键是分号(;)比较直观的就是如果分号被过滤或者无法绕过就无法注入，当然还有一些数据库引擎不支持，权限不足等限制。 6, Inline queries（内联查询注入） 一般较少遇到这种情况。 sqlmap根据6大类型探测技术生成的payload就放在sqlmap源码中\\xml\\payloads文件中，根据探测技术分为6个后缀为.xml的文件,每个xml文件分别存放每种注入技术的payload。 到这里突然发现目前用的notepad++里插件的markdown，不支持图片插入，尴尬==我之后再改吧。。 xml就是可扩展标记语言，标准通用标记语言的子集，简单来说就是sqlmap用xml语言来定义多个不同的标签组成一个payload的模板，每个标签有设置不同的等级，通过这样的方式可以实现灵活组合和调用payload。所以我们就必须先了解sqlmap定义的每个标签的意思和作用。 以下是从别处帖子po来的：标签的意思和作用可以直接通过在sqlmap源码的\\xml文件夹中的boundaries.xml文件以及\\xml\\payloads文件夹下的.xml文件的注释中查看,通过查询xml文件中的注释，我们知道sqlmap上的boundaries.xml定义的以及payload文件下的xml定义的标签均与sqlmap的payload有密切关系。&lt; boundary &gt;定义了sqlmap注入语句的边界问题，包括注入的发包数量等级，使用的查询从句，注入的位置，使用的特殊字符，前缀，后缀等。为我们清晰地划分了sqlmap注入时的所需要的各个模块等级。而&lt; test &gt;则定义了比较细致完整的测试实例，俗称payload。由上面的和相结合我们可以得到如下测试语句。 最终的payload = where + boundary.prefix+test.payload+boundary.suffix，影响最终payload的生成主要由,标签决定的，当且仅当某个boundary元素的where节点的值包含test元素的子节点where的值，clause节点的值包含test元素的子节点的clause的值时候，该boundary才能和当前的test匹配生成最终的payload。经过测试发现除了这两个文件决定最终payload的生成，还包括sqlmap使用的注入方式以及payload使用的查询语句有关。如果把这两个文件比作两个集合，生成的payload比作两个集合的映射，则这两个集合之间的映射关系是多对多的关系。 之后等我继续学习这篇文章再来写写收获吧。","categories":[],"tags":[]},{"title":"Python学习历程","slug":"Python学习历程","date":"2018-01-23T13:06:06.000Z","updated":"2018-01-23T13:14:50.230Z","comments":true,"path":"2018/01/23/Python学习历程/","link":"","permalink":"https://ly1988.github.io/2018/01/23/Python学习历程/","excerpt":"","text":"========== Python学习历程 ==========- Python是一种什么语言Python是一种计算机程序设计语言。你可能已经听说过很多种流行的编程语言，比如非常难学的C语言，非常流行的Java语言，适合初学者的Basic语言，适合网页编程的JavaScript语言等等。首 先，我们普及一下编程语言的基础知识。用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个MP3，编写一个文档等等，而计算机干活的CPU只 认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很 大。比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。所以Python是一种相当高级的语言。-学习Python对我们来说是否有难度是不是越低级的程序越难学，越高级的程序越简单？表面上来说，是的，但是，在非常高的抽象计算中，高级的Python程序设计也是非常难学的，所以，高级程序语言不等于简单。但是，对于初学者和完成普通任务，Python语言是非常简单易用的。 - 用Python可以做什么可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。Python当然也有不能干的事情，比如写操作系统，这个只能用C语言写；写手机应用，只能用Objective-C（针对iPhone）和Java（针对Android）；写3D游戏，最好用C或C++。许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 - 学习Python需要做什么准备学习Python必不可少的一部肯定是工具，一种是编码器，一种是解释器：1）编码器就是Python。目前，Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的，因为现在Python正在朝着3.x版本进化，在进化过程中，大量的针对2.x版本的代码要修改后才能运行，所以，目前有许多第三方库还暂时无法在3.x上使用。2）IDE工具。IDE集成开发环境（简称IDE）软件是用于程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。常见使用的工具是：——1）Pycharm: PyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。——2）IDLE: Idle 是一个纯 Python 下使用 Tkinter 编写的相当基本的 IDE。——3）Ipython: ipython 是一个 python 的交互式 shell，比默认的python shell 好用得多。 - 学习Python后能做什么例如运维、web开发、应用开发、大数据、数据挖掘、科学计算、机器学习、人工智能、自然语言处理等","categories":[],"tags":[]},{"title":"学期总结&寒假计划","slug":"学期总结-寒假计划","date":"2018-01-23T13:06:01.000Z","updated":"2018-01-23T13:21:26.029Z","comments":true,"path":"2018/01/23/学期总结-寒假计划/","link":"","permalink":"https://ly1988.github.io/2018/01/23/学期总结-寒假计划/","excerpt":"","text":"========== 学期总结&amp;寒假计划 ==========心路历程首先，本学期作为一个转专业的学生，一开始是有点不适应的，但好在班里的同学都还是很友好的，功能共同为我们这个班级营造了浓厚的学习氛围。 我呢，自觉技术是不太行的，但在过去的半学期里也算是在努力充实自己，填充自己。（实验室的学习氛围也是挺好的） 上面就是一堆碎碎念的话，不要在意。 上学期总结然后这学期在专业的信安学习方面也才算入了个门，懂得了大概的学习方法，掌握了必要的知识。 在网络攻防这门专业课上也是跟着老师的节奏在慢慢学习，主要分为： * SQL注入 数字型注入 字符型注入 过滤了特殊符号的注入 过滤了逗号，的注入 报错注入（floor，extractvalue，updatexml） 基于h时间的盲注（sleep函数，benchmark函数） * XSS 反射型 存储型 * CSRF * 文件上传 * 文件包含 * 暴力破解 总之，这门课就是对渗透知识最基础的作了讲解。 寒假计划除此之外，对于已经过了半的寒假，之前我花了功夫学习python，接下来就是想继续加深python的学习。 博客我就慢慢更吧，有点懒。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-10-05T09:58:44.587Z","updated":"2017-10-05T09:58:44.587Z","comments":true,"path":"2017/10/05/hello-world/","link":"","permalink":"https://ly1988.github.io/2017/10/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}